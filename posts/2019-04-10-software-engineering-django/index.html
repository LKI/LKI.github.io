<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.59.1" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Lirian Su" />
  <meta property="og:url" content="https://liriansu.com/posts/2019-04-10-software-engineering-django/" />
  <link rel="canonical" href="https://liriansu.com/posts/2019-04-10-software-engineering-django/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/liriansu.com\/"
      },
      "articleSection" : "posts",
      "name" : "软件工程实践之 django\/python",
      "headline" : "软件工程实践之 django\/python",
      "description" : "软件工程实践系列文章， 会着重讲述实际的工程项目中是如何协作开发软件的。 本文主要介绍了 django\/python 系列的工具链。\n outline 本文包括以下内容：\n outline django: 一个搭建后端服务的工具箱。  framework: django vs flask\/tornado\/spring\/laravel restful: django\/restframework\/swagger worker: django\/uwsgi\/gevent\/celery\/channels database: django\/mysql\/sqlite\/migrations  python: 一门依赖开发者的语言。  developing: gitlab\/pipenv\/docker quality: unittest\/pytest\/flake8\/pylint\/yapf deploy: fabric\/aws\/nginx  conclusion  django django 是一个大名鼎鼎的后端开发框架， 它自己的口号是 the web framework for perfectionists with deadlines.\n在我用 django 开发的这几年来， 我觉得它是一个逻辑上自洽， 并且为了逻辑自洽甚至舍弃了一部分功能的框架。\nframework \x26gt; search google for django vs\n讲框架避免不了的是同行竞争， 比如到网上搜一下 django vs ... 就有一大堆搜索结果。 其实框架之间的比较是很难的， 每种框架都有自己适合的业务场景。\n\x26gt; xkcd-927: standards",
      "inLanguage" : "en-US",
      "author" : "Lirian Su",
      "creator" : "Lirian Su",
      "publisher": "Lirian Su",
      "accountablePerson" : "Lirian Su",
      "copyrightHolder" : "Lirian Su",
      "copyrightYear" : "2019",
      "datePublished": "2019-04-10 22:09:55 \x2b0000 UTC",
      "dateModified" : "2019-04-10 22:09:55 \x2b0000 UTC",
      "url" : "https:\/\/liriansu.com\/posts\/2019-04-10-software-engineering-django\/",
      "keywords" : [  ]
  }
</script>
<title>软件工程实践之 django/python - 浮云计算</title>
  <meta property="og:title" content="软件工程实践之 django/python - 浮云计算" />
  <meta property="og:type" content="article" />
  <meta name="description" content="软件工程实践系列文章， 会着重讲述实际的工程项目中是如何协作开发软件的。 本文主要介绍了 django/python 系列的工具链。
 outline 本文包括以下内容：
 outline django: 一个搭建后端服务的工具箱。  framework: django vs flask/tornado/spring/laravel restful: django/restframework/swagger worker: django/uwsgi/gevent/celery/channels database: django/mysql/sqlite/migrations  python: 一门依赖开发者的语言。  developing: gitlab/pipenv/docker quality: unittest/pytest/flake8/pylint/yapf deploy: fabric/aws/nginx  conclusion  django django 是一个大名鼎鼎的后端开发框架， 它自己的口号是 the web framework for perfectionists with deadlines.
在我用 django 开发的这几年来， 我觉得它是一个逻辑上自洽， 并且为了逻辑自洽甚至舍弃了一部分功能的框架。
framework &gt; search google for django vs
讲框架避免不了的是同行竞争， 比如到网上搜一下 django vs ... 就有一大堆搜索结果。 其实框架之间的比较是很难的， 每种框架都有自己适合的业务场景。
&gt; xkcd-927: standards" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet"
    href="/css/github-markdown.min.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="浮云计算">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  

  
</head>


<body>
  <article class="post 中文" id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Lirian Su</a>
  </div>
</header>
<div class="row end-xs">
  
  
  <div class="lang-switch col-xs-3 col-xs-offset-9">
    <a href="/en/">English</a>
  </div>
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">软件工程实践之 django/python</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-04-10 22:09:55 UTC">
                10 Apr 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="">@Lirian Su</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          

<p>软件工程实践系列文章，
会着重讲述实际的工程项目中是如何协作开发软件的。
本文主要介绍了 django/python 系列的工具链。</p>

<!--MORE-->

<h2 id="outline">outline</h2>

<p>本文包括以下内容：</p>

<ul>
<li>outline</li>
<li>django: 一个搭建后端服务的工具箱。

<ul>
<li>framework: django vs flask/tornado/spring/laravel</li>
<li>restful: django/restframework/swagger</li>
<li>worker: django/uwsgi/gevent/celery/channels</li>
<li>database: django/mysql/sqlite/migrations</li>
</ul></li>
<li>python: 一门依赖开发者的语言。

<ul>
<li>developing: gitlab/pipenv/docker</li>
<li>quality: unittest/pytest/flake8/pylint/yapf</li>
<li>deploy: fabric/aws/nginx</li>
</ul></li>
<li>conclusion</li>
</ul>

<h2 id="django">django</h2>

<p><a href="https://github.com/django/django">django</a> 是一个大名鼎鼎的后端开发框架，
它自己的口号是 <code>the web framework for perfectionists with deadlines.</code></p>

<p>在我用 django 开发的这几年来，
我觉得它是一个逻辑上自洽，
并且为了逻辑自洽甚至舍弃了一部分功能的框架。</p>

<h3 id="framework">framework</h3>

<p><img src="/assets/pics/se/django_vs.png" alt="django-vs" />
&gt; search google for <code>django vs</code></p>

<p>讲框架避免不了的是同行竞争，
比如到网上搜一下 <code>django vs ...</code> 就有一大堆搜索结果。
其实框架之间的比较是很难的，
每种框架都有自己适合的业务场景。</p>

<p><img src="https://imgs.xkcd.com/comics/standards.png" alt="xkcd-927" />
&gt; xkcd-927: standards</p>

<p>django 最大的特点就是 <strong><code>Model</code> 是一等公民</strong>。
在 django 中的所有的操作都会跟 <code>Model</code> 相关，
比如它提供了自带的强大 ORM,
也有一系列挂载在 <code>Model</code> 上的校验等。</p>

<p>个人感觉在项目的业务需求达到了某种程度的多样化以后，
基础框架用什么并不重要，
适合开发团队才是最重要的。</p>

<p>鉴于本文的标题是 django,
所以我们只讲 django。</p>

<h3 id="restful">restful</h3>

<p>我参与的项目基本都是前后端分离的项目，
后端提供的接口都是用 <code>djangorestframework</code> 写的。
虽然像 <code>HATEOAS</code> 这样的高级属性还没用到，
但接口是遵循 <code>restful</code> 风格的，
比如像用 http method+status 表达语义，
对资源的定义等。</p>

<p>接口文档我们选用了 <code>drf-yasg</code> 来生成符合 <code>swagger</code> 规范的文档。
曾经我们也试过 <code>django-rest-swagger</code> 这个库，不过……</p>

<p><img src="/assets/pics/se/django_rest_swagger.png" alt="django-rest-swagger-readme" />
&gt; another help-wanted project&hellip;</p>

<p>使用现成框架的好处是语言表达力极强，
最终我们实现一个“解密微信提供的手机号”接口的<del>伪</del>业务代码大概如下：</p>

<pre><code class="language-python3">class WeChatVS(BaseVS):

    @with_response(empty=True)
    @with_request(DecryptionSiri)
    @action(methods=['post'], detail=True, url_path='decryption/phone')
    def decrypt_wechat_phone(self, request, uid):
        &quot;&quot;&quot; 解密并修改用户的手机号
        - https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html
        &quot;&quot;&quot;
        self.check_account_request(request, uid)
        openid, encrypted_data, initial_vector = self.request_data
        phone = WeChatManager(openid).decrypt_safely(encrypted_data, initial_vector)
        # TODO(ldsink): 找产品问一下外国手机号怎么处理
        hutils.check_error(not hutils.is_chinese_phone(phone), 'o(╥﹏╥)o 目前只支持国内的手机号')
        self.account.modify(phone=phone)
        return self.empty_response()
</code></pre>

<p>这样的十行代码包含了文档、外链、错误检查、写库，
让写业务代码本身也有种施法的快感。</p>

<h3 id="worker">worker</h3>

<p>最开始服务器上我们跑的是 django+uwsgi 的普通模式，
用 <code>wrk</code> 去压一个小接口，
测试环境 4G 内存的机器 QPS 只有 40 左右。
后来加上了 gevent, monkey patch 一下，改到了协程模式
同样的接口同样的机器 QPS 上升到了大概 600。
调优一下效果会更好。
（需要更高性能的业务可能就根本不用 python 了 Orz）</p>

<p>celery 充当了我们的定时任务+异步任务框架，
我们也拆分了 读写密集型/计算密集型 的两类队列以处理不同的事情。
对于业务中的即时通知部分，
我们用了 channels 库来实现 web socket 的功能。</p>

<p>对于这些大型的框架，其实我们选择余地并不大。
比如虽然 django 开发者有说在 3.0 会考虑大幅度重写异步调用，
channels 项目会逐渐弃坑……
但毕竟 <code>perfectionists with deadlines.</code>
不能说人家功能不完美，我们就不干活了嘛&hellip;</p>

<h3 id="database">database</h3>

<p>我们用到的数据库也是 mysql/mongo/redis 这御三家，
所以就是每个选取对应的连接库就是了。</p>

<p>值得一提的是在单元测试里，
我们用 <code>sqlite(in-memory)</code> 替代了 mysql 数据库。
sqlite 里缺失了 mysql 的函数的问题，
也可以用 <code>connection.create_function</code> 的方法来规避掉。</p>

<p>在上线时，还有一个很好玩的东西是 <code>database migration</code>，
这个基本上跟“给行驶中的火车换轮子”一样刺激。
详细的细节以后会专门开篇文章讲一下（挖坑预警），
从结果上来说我们做到的是<strong>利用 Django Migration 做到数据库结构变更全兼容</strong>。</p>

<h2 id="python">python</h2>

<p>上面一小节中，我们基本上是走马观花地过完了 django 相关的三方库。
到了真正用 python 开发的时候，
我们遇到的更多的是框架之外的奇遇。</p>

<p>每门语言都有自己的味道。
我很喜欢 python 的一点是：
这门语言有着非常强的表达张力。
就像上面举的那段典型业务代码一样，
在实际的开发中，
python 是能完美表达开发者心中所想的。</p>

<p>但假如开发者自己都没想清楚自己要写啥，
这就有点不妙了。</p>

<p>所以我们有一系列的开发工具来保持清醒。</p>

<p><img src="/assets/pics/meme/stay_awake.jpg" alt="stay-awake" />
&gt; 强制清醒.jpg</p>

<h3 id="quality">quality</h3>

<p><img src="/assets/pics/se/hax_principles.png" alt="hax-principles" />
&gt; <a href="https://www.zhihu.com/question/300762444/answer/529335326">贺师俊在《如何引导程序员新人按正确的流程开发？》下面一段我很欣赏的回答</a></p>

<p>除了开发流程上的类似要求，
我们对代码本身也执行了类似的严格要求：</p>

<ul>
<li>单元测试覆盖率必须得在 96% 以上 (unittest/pytest/coverage)</li>
<li>代码的逗号、换行、引号的使用都必须符合规范 (flake8)</li>
<li>代码强制经过 linter 检验，禁止多种黑魔法 (pylint)

<ul>
<li>代码的各个模块之间必须符合特定的拓扑顺序 (pylint-topology)</li>
</ul></li>
<li>代码风格（如字典的复制、长列表、换行与空行）强制统一 (yapf)</li>
</ul>

<p>其中<strong>单元测试覆盖率必须得在 96% 以上</strong>值得被单独拎出来表扬一下。</p>

<p>业务代码的 96% 的覆盖率是什么概念呢？
这意味着代码里只有那种真正的边缘情况是没被测到的。
（比如为了兼容微信 SYSTEM ERROR -1000 写的代码）</p>

<p>为了达到了这么高的覆盖率，
我们也专门强化过单元测试的表达力，
比如一段测试创建用户接口的<del>伪</del>代码可能如下：</p>

<pre><code class="language-python3">def test_create_account(self):
    &quot;&quot;&quot; 测试创建用户 &quot;&quot;&quot;
    with self.assert_model_increase(Account, delta=1):
        response = self.client.post(self.account_url(), {'username': 'hulucc'})
        self.ok(response, username='hulucc', tags__length=0)
    with self.assert_model_increase(Account, delta=0):
        response = self.client.post(self.account_url(), {'username': 'hulucc'})
        self.bad_request(response, message=AccountErrors.DUPLICATE.value)
</code></pre>

<p><img src="/assets/pics/se/gitlab_ci_sample.png" alt="gitlab-ci-sample" />
&gt; 所有这些限制都在 CI 中检查了，不通过的话是不让 merge into master 的</p>

<h3 id="developing">developing</h3>

<p>我们的合作方式是用 gitlab 作为代码托管平台。
为了团队的开发效率，
我们还自己写了个小机器人来处理各种如分支合并、有效性检查、贴标签之类的杂活。</p>

<p>gitlab ci 不仅被用来做开发阶段的质量保证，
最终我们的构建上线也走的是 gitlab ci <a href="/python-deployment-automation-one-sample">(以前我们用的是 jenkins)</a></p>

<p><img src="/assets/pics/se/gitlab_pr_sample.png" alt="gitlab-pr-sample" /></p>

<p>对于 python 的依赖管理，
我们用的是 pipenv,
<code>pip list</code> 一下大概有了 181 个库。
(关于 pipenv 的介绍可以参见<a href="https://ldsink.com/archives/the-future-of-python-dependency-management/">《Python 依赖管理的未来 - ldsink》</a>)</p>

<p>也因为我们线上用的是 docker,
所以不想装依赖的也可以直接用 docker 的环境开发。</p>

<h3 id="deploy">deploy</h3>

<p>部署这一块我们暂时还没上 k8s,
目前走的是 gitlab ci 中调用 fabric + aws(boto3) 直接操作裸 docker 的方式。
aws 的负载均衡器提供了基础的流量切换服务，
我们也是借用了现成的服务达到灰度发布、无缝发布的效果。</p>

<p><img src="/assets/pics/se/gitlab_ci_deploy.png" alt="gitlab-ci-deploy" />
&gt; 用 GitLab CI 部署的步骤图</p>

<h2 id="conclusion">conclusion</h2>

<p>至此，本文介绍了一遍我们在 Python 业务后端的实践。</p>

<p>对于高可用、容器化、数据库等屠龙技，
业界其实有非常多的探讨，
大家也很容易找到现成的文章。</p>

<p>但具体到业务后端的工程化实践，
能借鉴的大型项目并不多。
我读过的也只有<a href="https://github.com/reddit-archive/reddit">两年前的 reddit 代码</a>跟 <a href="https://github.com/getsentry/sentry">sentry</a> 这个 django 项目符合要求了。</p>

<p>总的来说，我们用 django 在开发中遵循的约定跟共识有这些：</p>

<ul>
<li>做正确的事情。

<ul>
<li>比如我们在讨论过后，一致觉得“线性的 Commit 历史是最干净的”，从当天开始我们的 Commit 历史就是干净的线性历史了。</li>
</ul></li>
<li>自动化一切能自动化的工作。

<ul>
<li>用 swagger 自动化生成文档，用 gitlab ci 自动化质量保证。</li>
</ul></li>
<li>尽可能使用最新的特性，让代码时刻保持崭新。

<ul>
<li>我们每隔一阵就会把所有依赖升到最新的稳定版。</li>
<li>不过因为这个我们也踩了不少坑。</li>
<li>不少时候三方库会引入全新的用法，动辄改动 100+ 的文件数。</li>
<li>这个时候就到了 Vim Macro 展现魔法的时候了。</li>
</ul></li>
</ul>

<p>假如你也在用 Django 作为后端框架的话，
不防尝试一下上面提到的各类工具，
绝对物超所值噢 :)</p>

        </div>
        

        


        
        
        <div style="height: 50px;"></div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/about" target="_blank">about</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/LKI/LKI" target="_blank">github</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/index.xml" target="_blank">rss</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();

  
  
    
    
  
</script>

  

</body>

</html>